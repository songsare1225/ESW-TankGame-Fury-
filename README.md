# ESW-TankGame-Fury-
ESW project - tank game

## 배경

## 아이디어

## 게임방법
1. 게임 시작
게임은 특정 화면에서 시작하며, main() 함수 내에서 실행됩니다.
플레이어는 주로 키보드, 마우스 또는 조이스틱을 사용하여 게임을 제어할 수 있습니다.
조작 방식:
조이스틱 또는 버튼 A를 사용하여 캐릭터의 이동 및 공격을 제어합니다.
게임 화면에 지형(terrain), 캐릭터, 총알, 적군 등이 그려지고, 게임이 시작됩니다.
2. 캐릭터 이동
플레이어는 화면 내에서 캐릭터를 좌우로 이동시킬 수 있습니다.
이동은 joystick 객체의 move 명령으로 처리됩니다. 캐릭터의 x축 좌표를 조작하여 좌우로 움직입니다.
캐릭터는 중력의 영향을 받으며, 화면 아래쪽에 있는 지형(terrain) 위에 서 있거나 점프하는 방식으로 이동합니다.
조작 방법: 왼쪽/오른쪽 방향키, 조이스틱 이동 등
3. 총알 발사
플레이어는 A 버튼을 눌러 총알을 발사할 수 있습니다.
총알은 플레이어가 조작하는 캐릭터의 **포탑(turret)**에서 발사됩니다. 포탑의 발사 각도는 my_circle.turret_angle 값에 의해 결정됩니다.
총알은 일정 속도(self.speed)로 화면을 가로질러 이동하며, 중력(self.gravity)에 의해 떨어집니다.
총알 발사 과정:
bullet = Bullet()을 통해 총알이 생성되며, 발사 위치와 각도, 속도 등이 설정됩니다.
총알은 move() 메서드로 이동하며, collision_check()를 통해 적과의 충돌을 확인하고, 지형과의 충돌도 검사합니다.
충돌 시, 총알은 '폭발' 상태로 변경되며, animate_explosion() 메서드를 통해 폭발 애니메이션이 진행됩니다.
4. 적군의 등장 및 행동
적군은 일정 간격으로 스폰되고, 플레이어의 위치를 따라 이동하거나 공격을 합니다.
적군은 각기 다른 이미지와 크기를 가지며, 화면을 왼쪽에서 오른쪽으로 이동합니다.
적군은 총알에 맞으면 죽고, 죽은 후에는 state가 'die'로 설정됩니다.
적군과의 전투:
플레이어가 발사한 총알이 적군과 충돌하면, 적군의 상태가 'die'로 변경되고, 총알은 'exploding' 상태가 됩니다.
적군의 총알은 enemys_bullets 리스트에서 관리되며, 플레이어가 맞으면 체력이 감소합니다.
5. 충돌 및 피해 처리
플레이어의 체력은 적군의 총알이나 지형과 충돌할 때 감소합니다.
my_circle.position과 총알의 위치가 겹치면, 체력이 감소하고 총알은 '폭발' 상태로 변합니다.
적군과의 충돌 시, 적군은 'die' 상태가 되며, 캐릭터가 맞으면 체력이 감소합니다.
체력 바는 게임 화면에 표시되어, 체력의 변화를 시각적으로 확인할 수 있습니다.
6. 배경 및 화면 업데이트
게임 화면은 매 프레임마다 배경, 지형, 캐릭터, 총알, 적군 등을 갱신합니다.
배경은 background_image로 설정된 이미지를 사용하고, terrain_height와 terrain_offset을 사용하여 지형을 생성합니다.
배경은 화면을 반복하여 그리며, alpha_composite()를 사용하여 각 레이어를 결합합니다.
각 객체(캐릭터, 총알, 적군 등)의 위치는 my_image 객체에 그려지며, 게임 루프 내에서 joystick.disp.image()로 화면에 출력됩니다.
7. 체력 바와 UI
화면 왼쪽 상단에는 체력 바가 표시됩니다.
체력 바는 health_fill_image와 health_bar_image로 생성되며, current_health에 따라 동적으로 업데이트됩니다.
체력이 변할 때마다 체력 바의 크기도 변화하여, 플레이어가 얼마나 많은 피해를 입었는지 알 수 있습니다.
8. 게임 종료 조건
게임이 종료되는 조건은 명확하게 구현되어 있지 않지만, 플레이어의 체력이 0에 도달하면 게임이 종료될 수 있습니다.
적군을 모두 처치하거나, 플레이어가 더 이상 총알을 발사할 수 없는 경우 게임을 종료할 수 있습니다.


## 사용된 기술
1. 객체 지향 프로그래밍 (OOP)
기술: Python의 객체 지향 프로그래밍(OOP) 개념을 활용하여 게임의 각 요소(캐릭터, 적군, 총알 등)를 클래스로 정의하고, 이들 간의 상호작용을 처리.
적용 예시:
Bullet, Enemy, Character, Joystick 클래스가 각기 다른 게임 요소를 객체화하여, 해당 요소들의 상태, 동작, 충돌 등을 관리합니다.
__init__, __str__, __repr__ 등과 같은 기본적인 OOP 메서드들을 사용하여 객체 초기화 및 상태 관리.
2. 이미지 처리 (PIL/Pillow 라이브러리)
기술: PIL (Python Imaging Library) 또는 그 후속 라이브러리인 Pillow를 사용하여 이미지 크기 조정, 합성 및 변환을 처리.
적용 예시:
Image.open(), Image.resize(), alpha_composite() 등을 사용하여 게임 캐릭터, 총알, 적군, 배경 이미지 등을 화면에 출력합니다.
총알의 폭발 애니메이션 처리 및 이미지 리사이징을 통해 다양한 크기의 이미지를 다룹니다.
3. NumPy
기술: NumPy를 사용하여 수학적 연산 및 벡터 기반의 위치 계산을 처리.
적용 예시:
np.array를 사용하여 위치를 (x_min, y_min, x_max, y_max) 형태로 표현하고, 객체들의 위치와 크기 계산에 활용.
벡터 연산 (np.cos, np.sin)을 사용하여 총알의 발사 각도를 기반으로 속도 벡터를 계산합니다.
충돌 감지 및 위치 계산에서 NumPy 배열을 사용하여 더 효율적으로 데이터를 처리합니다.
4. 충돌 감지 알고리즘
기술: 2D 충돌 감지 알고리즘을 사용하여 객체 간 충돌을 확인.
적용 예시:
overlap() 메서드를 통해 두 객체의 bounding box(경계 상자)가 겹치는지 확인하고 충돌 여부를 반환합니다.
collision_check()에서 overlap()을 활용하여 총알이 적군이나 캐릭터와 충돌하는지 판단하고, 충돌 시 상태 변경과 체력 감소를 처리합니다.
5. 시간 기반 이벤트 처리
기술: time.sleep() 및 time_step을 사용하여 게임 내 시간 흐름을 제어하고, 물리 엔진을 구현합니다.
적용 예시:
time_step을 사용하여 총알의 이동 속도나 중력 효과가 시간에 따라 변화하도록 만듭니다.
게임 루프에서 일정한 시간 간격으로 객체들을 업데이트하고, 애니메이션을 진행합니다.
6. 게임 루프 및 상태 관리
기술: 기본적인 게임 루프를 구현하여 게임의 상태를 주기적으로 업데이트하고, 화면을 새로고침합니다.
적용 예시:
main() 함수 내에서 게임 루프를 돌면서, 각 프레임마다 캐릭터, 총알, 적군 등을 이동시키고, 충돌을 체크하며, 화면을 새로 고칩니다.
사용자 입력, 적군 AI, 총알 상태 등을 매 프레임마다 업데이트합니다.
7. 애니메이션 처리
기술: 폭발 애니메이션과 같은 동적 이미지 처리를 위해 여러 이미지 프레임을 순차적으로 표시하는 방식입니다.
적용 예시:
animate_explosion() 메서드에서 폭발 애니메이션 프레임을 순차적으로 보여줍니다.
폭발의 각 프레임을 이미지로 관리하고, 충돌 후 총알의 상태가 'exploding'으로 바뀌면 애니메이션을 진행합니다.
8. 2D 물리 엔진 (Gravity, Velocity)
기술: 2D 물리 엔진을 간단하게 구현하여 중력과 속도를 처리합니다.
적용 예시:
총알의 궤적을 계산할 때 중력의 영향을 고려하여 move() 메서드에서 self.velocity_y와 self.gravity를 통해 총알의 y 위치를 계산합니다.
중력 적용을 위해 0.5 * self.gravity * (self.time ** 2)의 물리 공식을 사용합니다.
9. 게임 내 UI (체력 바 등)
기술: 체력 바와 같은 UI 요소를 게임 화면에 표시하기 위해 이미지 조작을 사용합니다.
적용 예시:
체력 바는 Image.new()를 사용하여 동적으로 생성하고, alpha_composite()로 화면에 그립니다.
health_fill_image와 health_bar_image를 사용하여 캐릭터의 체력을 시각적으로 표시합니다.
10. 입력 처리 (Joystick 또는 버튼 입력)
기술: joystick.py를 통해 사용자의 입력을 처리하고, 게임 오브젝트를 제어합니다.
적용 예시:
joystick.button_A.value와 같은 입력을 확인하여 캐릭터의 이동이나 총알 발사 등 주요 동작을 트리거합니다.
외부 USB 조이스틱 입력도 함께 처리하여 다양한 입력 방식을 지원합니다.
11. 상태 기반 프로그래밍
기술: 게임 내 객체들이 상태에 따라 다르게 동작하도록 상태 기반 프로그래밍을 적용합니다.
적용 예시:
Bullet 클래스에서 state 속성을 사용하여 active, hit, exploding, finished 등의 상태를 관리합니다.
적군과 총알, 캐릭터 등의 상태를 기반으로 게임의 흐름을 제어하고, 적절한 동작을 실행합니다.
12. 게임 오브젝트의 이미지 합성 (Alpha Blending)
기술: 알파 채널을 이용한 이미지 합성(Alpha blending)을 사용하여 이미지가 서로 겹치는 부분에서 투명도를 조절합니다.
적용 예시:
alpha_composite() 메서드를 사용하여 여러 이미지를 합성하고, 화면에 표시할 때 이미지의 겹침을 처리합니다.
배경, 지형, 캐릭터, 총알 등 다양한 요소들을 자연스럽게 겹쳐서 게임 화면을 그립니다.
종합적인 기술 스택 정리
Python: 게임 로직과 객체 관리의 주요 프로그래밍 언어.
Pillow (PIL): 이미지 처리 및 애니메이션 프레임 관리.
NumPy: 벡터 연산 및 수학적 계산 처리.
게임 루프: 매 프레임마다 상태를 업데이트하고 화면을 갱신.
물리 엔진 (Gravity, Velocity): 총알의 궤적 계산과 중력 적용.
충돌 감지 알고리즘: 객체 간 충돌을 확인하고 상태를 업데이트.
UI 요소 (체력 바): 게임 내 UI 표시 및 관리.
입력 처리: 조이스틱 또는 버튼 입력 처리.
상태 기반 프로그래밍: 게임 오브젝트의 상태에 따른 행동 관리.
알파 블렌딩: 이미지 합성을 통한 화면 구성.


## 문제점과 해결책
게임을 개발하면서 발생한 문제는 크게 아래와 같습니다.

1. 충돌 검사 및 상태 업데이트 관련 문제
문제: 여러 클래스(특히 Bullet과 Enemy)에서 충돌 검사를 처리하면서 상태 변경이 제대로 이루어지지 않는 경우가 있었습니다.
예를 들어, 총알이 적군과 충돌했을 때 적군의 상태를 'die'로 변경하고, 총알 상태를 'exploding'으로 변경하는 코드가 있지만, 충돌이 제대로 감지되지 않거나 상태가 갱신되지 않는 경우가 발생할 수 있습니다.
해결책:
충돌 검사 로직을 점검하고, 각 객체들의 state가 올바르게 변경되는지 확인해야 합니다.
overlap 메서드와 collision_check 메서드를 활용하여 충돌 여부를 정확히 판단하고, 충돌 시 상태를 적절히 업데이트하는지 확인합니다.
2. 게임 내 물리 엔진 관련 문제
문제: 물리적인 상호작용(예: 중력, 총알의 궤적, 충돌 등)에 대한 처리가 일관되지 않거나 부족한 부분이 있었습니다.
총알이 발사된 후 중력에 의해 궤적이 변경되도록 하였지만, 이 과정에서 충돌과 상호작용이 제대로 반영되지 않은 경우가 있었습니다.
또한, 지형과의 충돌 검사 및 상태 업데이트가 부정확할 수 있습니다.
해결책:
총알의 이동 및 중력 적용 로직을 개선하여 더욱 자연스럽고 예측 가능한 궤적을 만들 필요가 있습니다.
terrain_collision_check 메서드를 확실히 점검하고, 총알이 지형과 충돌할 때 정확한 처리 로직을 확인합니다.
중력이나 속도를 적용할 때 시간 간격을 고려해 time_step과 같은 매개변수를 적절히 사용합니다.
3. 게임 오브젝트의 위치 및 크기 계산 문제
문제: Bullet 클래스나 Enemy 클래스에서 위치와 크기를 계산하는 방식이 불완전할 수 있습니다. 예를 들어, 총알과 적군의 충돌을 확인할 때 위치와 크기 계산이 정확하지 않을 수 있습니다.
Bullet과 Enemy 객체의 position 속성이 (x_min, y_min, x_max, y_max) 형태로 저장되어 있는데, 이 값을 다룰 때 정확한 계산이 필요합니다.
해결책:
객체들의 위치와 크기를 계산할 때, 정확한 중심 좌표와 경계값을 고려하여 충돌이 제대로 처리되도록 합니다.
get_center 메서드를 활용하여 중심 좌표를 정확히 계산하고, overlap 메서드로 충돌 여부를 체크합니다.
충돌 검사에서 각 객체의 position을 확인할 때, x_min, x_max, y_min, y_max 값을 명확히 구분하여 사용해야 합니다.
4. 게임 내 상태 변경 및 애니메이션 문제
문제: 객체들의 상태 변경(예: 'active', 'exploding', 'finished')과 애니메이션 처리에 있어, 상태가 변경되었을 때 애니메이션이나 다른 효과가 제대로 반영되지 않는 경우가 있었습니다.
예를 들어, 총알이 폭발 상태로 변경되었을 때 폭발 애니메이션이 적절하게 진행되지 않거나, 애니메이션이 끝난 후 상태가 finished로 갱신되지 않는 경우가 발생할 수 있습니다.
해결책:
애니메이션 상태를 animate_explosion 메서드에서 관리하고, 애니메이션이 끝난 후 state를 'finished'로 정확히 변경하는지 확인합니다.
게임 객체들이 상태 변경을 할 때, 이를 명확히 추적하고, 필요한 애니메이션이나 효과가 제대로 반영될 수 있도록 해야 합니다.
5. 입력 처리 및 조이스틱 관련 문제
문제: joystick.py에서 사용자 입력을 처리할 때, 여러 버튼이나 방향키 입력을 동시에 처리하는 데 문제가 있을 수 있습니다.
예를 들어, 사용자 입력이 적절히 처리되지 않거나, 여러 버튼이 동시에 눌렸을 때 그에 따른 동작이 제대로 이루어지지 않는 경우가 발생할 수 있습니다.
해결책:
조이스틱 입력 처리에서 여러 입력을 동시에 처리하는 방식이나 우선순위를 잘 설정하여, 충돌이 발생하지 않도록 해야 합니다.
joystick.py에서 버튼 및 방향키 입력을 처리할 때, 입력 이벤트가 발생할 때마다 상태를 정확히 업데이트하고, 그에 맞는 행동을 하도록 합니다.
6. 게임 오브젝트의 렌더링 및 화면 업데이트 문제
문제: 여러 게임 객체를 화면에 렌더링할 때, 화면이 제대로 업데이트되지 않거나, 객체들이 올바르게 배치되지 않는 문제가 발생할 수 있습니다.
예를 들어, 배경 이미지와 캐릭터, 적군 등이 서로 겹쳐서 보이는 경우나, 렌더링 순서가 잘못되어 화면이 왜곡되는 경우가 있을 수 있습니다.
해결책:
각 게임 오브젝트의 렌더링 순서를 명확히 정의하고, 화면에 표시할 때 올바른 순서로 객체들이 렌더링되도록 해야 합니다.
my_image.alpha_composite()와 같은 메서드를 사용할 때, 각 오브젝트가 적절히 겹쳐서 나타나도록 순서를 관리합니다.
7. 체력 시스템 및 UI 표시 문제
문제: 체력 바가 올바르게 표시되지 않거나, 체력이 변경될 때 UI가 제대로 갱신되지 않는 문제입니다.
체력 상태를 화면에 표시하는 부분에서 UI가 갱신되지 않거나, 체력이 0이 되어도 적절한 처리가 이루어지지 않는 문제가 발생할 수 있습니다.
해결책:
health_fill_image와 같은 체력 바를 업데이트하는 부분을 점검하여, 체력이 감소할 때 UI가 제대로 반영되도록 해야 합니다.
체력이 0일 때 게임 종료 로직을 추가하여, 게임의 진행을 제어할 수 있도록 합니다.


## 코드설명
각 코드에 대한 세분화된 설명은 게임 디렉토리 안 각 py 파일에 주석처리 되어있습니다.
아래 내용들은 각 py의 큰 역할에 대한 설명을 작성하였습니다.

1. enemy.py (적군 클래스)
역할: 게임에서 적군을 나타내는 클래스입니다.

주요 기능:

적군 생성: 적군의 위치, 크기, 이미지 등을 초기화합니다.
위치 업데이트: 적군이 일정 거리만큼 x축으로 이동할 수 있도록 update_position 메서드로 위치를 업데이트합니다.
중앙 좌표 계산: 적군의 위치에서 중심 좌표를 계산할 수 있는 get_center 메서드를 제공합니다.
상태 관리: 적군의 상태 ('alive', 'die')를 관리합니다.
사용 예시: 적군이 게임 화면을 가로지르며 이동하고, 충돌할 경우 적군의 상태를 'die'로 변경하는데 사용됩니다.

2. bullet.py (총알 클래스)
역할: 게임에서 총알을 관리하는 클래스입니다.

주요 기능:

총알 생성 및 초기화: 총알의 초기 위치, 속도, 각도, 이미지, 폭발 애니메이션 등을 초기화합니다.
이동: 총알이 일정 시간 간격으로 이동하도록 move 메서드를 제공합니다. 중력과 속도를 고려하여 총알의 위치를 업데이트합니다.
충돌 처리: collision_check 메서드로 다른 객체(주로 적군이나 캐릭터)와 충돌하는지 확인하고, 충돌 시 적군을 죽이거나 체력을 감소시킵니다.
지형 충돌: terrain_collision_check 메서드로 지형과의 충돌을 처리합니다.
폭발 애니메이션: 충돌 시 폭발 애니메이션을 진행하는 animate_explosion 메서드를 제공합니다.
중앙 좌표 계산: 총알의 중심을 계산하여 반환하는 get_center 메서드가 있습니다.
사용 예시: 총알이 발사된 후 이동하며, 적군과 충돌 시 적군을 죽이고 폭발 애니메이션을 실행합니다.

3. main.py (게임 실행 및 메인 루프)
역할: 게임의 메인 루프와 게임 흐름을 제어하는 파일입니다.

주요 기능:

게임 화면 업데이트: main() 함수에서 주기적으로 화면을 업데이트하며, 캐릭터, 적군, 총알, 지형 등 게임의 모든 요소를 렌더링합니다.
캐릭터 및 총알 발사: 캐릭터의 상태 및 위치를 업데이트하고, 사용자 입력(조이스틱, 버튼)에 따라 총알을 발사합니다.
적군 총알: 적군이 일정 시간 간격으로 총알을 발사하는 기능을 구현합니다.
충돌 처리: 총알과 적군, 총알과 지형, 총알과 캐릭터 간의 충돌을 처리합니다.
애니메이션 및 상태 업데이트: 캐릭터의 이동 애니메이션과 폭발 애니메이션을 처리합니다.
게임 UI: 체력 바와 같은 게임 UI 요소를 화면에 그립니다.
사용 예시: main.py는 게임의 메인 루프를 실행하여 게임을 지속적으로 업데이트하고, 모든 객체의 상태를 갱신하고 화면에 반영합니다.

4. character.py (캐릭터 클래스)
역할: 게임 캐릭터의 동작과 속성을 관리하는 클래스입니다.

주요 기능:

캐릭터 상태: 캐릭터의 위치, 크기, 이미지 등을 설정합니다.
애니메이션 처리: 캐릭터가 이동할 때 애니메이션을 처리하여, 걷기/멈추기와 같은 동작을 이미지로 표현합니다.
체력 관리: 캐릭터가 총알에 맞을 때 체력을 관리하고, 체력이 0이 되면 죽는 처리를 합니다.
사용 예시: main.py에서 캐릭터의 상태와 위치를 업데이트하며, 키 입력이나 버튼 입력에 따라 캐릭터의 애니메이션 및 이동을 처리합니다.

5. terrain.py (지형 클래스)
역할: 게임 내 지형을 관리하는 클래스입니다.

주요 기능:

지형 생성: 게임 내에 사용될 지형의 높이를 설정하고, 이를 기반으로 지형을 렌더링합니다.
지형 충돌 처리: 총알과의 충돌을 처리하여, 총알이 지형에 맞으면 폭발하도록 합니다.
사용 예시: 게임 화면에 지형을 표시하고, 총알이 지형과 충돌했을 때 이를 처리하는데 사용됩니다.

6. joystick.py (조이스틱 클래스)
역할: 조이스틱 입력을 관리하는 클래스입니다.

주요 기능:

입력 처리: 사용자로부터의 조이스틱 입력(버튼, 방향)을 처리하여 캐릭터의 움직임을 제어합니다.
디스플레이: 게임 화면을 출력하는 기능도 포함되어 있습니다. 디스플레이는 화면을 갱신하고, 그 위에 캐릭터, 총알, 적군, 지형 등을 그립니다.
사용 예시: main.py에서 조이스틱 입력에 따라 캐릭터 이동 및 총알 발사 등을 처리합니다.


전체적인 역할 요약:
enemy.py: 적군 객체 관리
bullet.py: 총알 객체 관리
main.py: 게임 실행 및 게임 흐름 제어
character.py: 캐릭터 객체 및 동작 관리
terrain.py: 지형 객체 및 충돌 관리
joystick.py: 사용자 입력 및 화면 출력 관리
utils.py: 공통 유틸리티 함수들
이 파일들은 각자의 역할을 명확히 나누어, 게임의 다양한 요소들이 서로 독립적으로 관리되고 조정될 수 있도록 설계되었습니다. 각 클래스는 독립적인 책임을 가지며, main.py에서 이들을 호출하여 게임을 실행하는 구조입니다.
